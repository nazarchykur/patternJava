Ітератор
Також відомий як: Iterator
     

     
Суть патерна
    Ітератор — це поведінковий патерн проектування, що дає змогу послідовно обходити елементи складових об’єктів, не 
    розкриваючи їхньої внутрішньої організації.
    
    

Проблема
    Колекції — це найпоширеніша структура даних, яку ви можете зустріти в програмуванні. Це набір об’єктів, зібраний в 
    одну купу за якимись критеріями.    
    
                        *-*-*-*                      *
       *-*-*-*-*-*      | | | |                    / |  \
                        * * * *                   *  *    *
                        | | | |                  /|      /|\\
                        *-*-*-*                 * *     * * * *
    
    Більшість колекцій виглядають як звичайний список елементів. Але є й екзотичні колекції, побудовані на основі дерев, 
    графів та інших складних структур даних.
    
    Незважаючи на те, яким чином структуровано колекцію, користувач повинен мати можливість послідовно обходити її елементи, 
    щоб виконувати з ними певні дії.
    
    У який же спосіб слід переміщатися складною структурою даних? Наприклад, сьогодні може бути достатнім обхід дерева в 
    глибину, але завтра виникне необхідність переміщуватися деревом по ширині. А на наступному тижні, хай йому грець, 
    знадобиться можливість обходу колекції у випадковому порядку.
  

Рішення
    Ідея патерна Ітератор полягає в тому, щоб винести поведінку обходу колекції з самої колекції в окремий об’єкт.                        
    
    Об’єкт-ітератор відстежуватиме стан обходу, поточну позицію в колекції та кількість елементів, які ще залишилося обійти. 
    дну і ту саму колекцію зможуть одночасно обходити різні ітератори, а сама колекція навіть не знатиме про це.
    
    До того ж, якщо вам потрібно буде додати новий спосіб обходу, ви зможете створите окремий клас ітератора, не змінюючи 
    існуючого коду колекції.



Структура
    1. Ітератор описує інтерфейс для доступу та обходу елементів колекцій.
    
    2. Конкретний ітератор реалізує алгоритм обходу якоїсь конкретної колекції. Об’єкт ітератора повинен сам відстежувати 
        поточну позицію при обході колекції, щоб окремі ітератори могли обходити одну і ту саму колекцію незалежно.
    
    3. Колекція описує інтерфейс отримання ітератора з колекції. Як ми вже говорили, колекції не завжди є списком. 
        Це може бути і база даних, і віддалене API, і навіть дерево Компонувальника. Тому сама колекція може створювати 
        ітератори, оскільки вона знає, які саме ітератори здатні з нею працювати.
    
    4. Конкретна колекція повертає новий екземпляр певного конкретного ітератора, зв’язавши його з поточним об’єктом колекції. 
        Зверніть увагу на те, що сигнатура методу повертає інтерфейс ітератора. Це дозволяє клієнтові не залежати від 
        конкретних класів ітераторів.
    
    5. Клієнт працює з усіма об’єктами через інтерфейси колекції та ітератора. Через це клієнтський код не залежить від 
        конкретних класів, що дозволяє застосовувати різні ітератори, не змінюючи існуючого коду програми.
       
       В загальному випадку клієнти не створюють об’єкти ітераторів, а отримують їх з колекцій. Тим не менше, якщо клієнтові 
       потрібний спеціальний ітератор, він завжди може створити його самостійно.



Застосування
    > Якщо у вас є складна структура даних, і ви хочете приховати від клієнта деталі її реалізації (з питань складності або безпеки).

        - Ітератор надає клієнтові лише кілька простих методів перебору елементів колекції. Це не тільки спрощує доступ до 
            колекції, але й захищає її від необережних або злочинних дій.
    
    > Якщо вам потрібно мати кілька варіантів обходу однієї і тієї самої структури даних.
      
        - Нетривіальні алгоритми обходу структури даних можуть мати досить об’ємний код. Цей код буде захаращувати все 
            навкруги — чи то самий клас колекції, чи частина бізнес-логіки програми. Застосувавши ітератор, ви можете 
            виділити код обходу структури даних в окремий клас, спростивши підтримку решти коду.
    
    > Якщо вам хочеться мати єдиний інтерфейс обходу різних структур даних.
      
        - Ітератор дозволяє винести реалізації різних варіантів обходу в підкласи. Це дозволить легко взаємозаміняти 
            об’єкти ітераторів в залежності від того, з якою структурою даних доводиться працювати.



Кроки реалізації
    1. Створіть загальний інтерфейс ітераторів. Обов’язковий мінімум — це операція отримання наступного елемента. Але 
        для зручності можна передбачити й інше. Наприклад, методи отримання попереднього елементу, поточної позиції, 
        перевірки закінчення обходу тощо.

    2. Створіть інтерфейс колекції та опишіть у ньому метод отримання ітератора. Важливо, щоб сигнатура методу повертала 
        загальний інтерфейс ітераторів, а не один з конкретних ітераторів.

    3. Створіть класи конкретних ітераторів для тих колекцій, які потрібно обходити за допомогою патерна. Ітератор повинен 
        бути прив’язаний тільки до одного об’єкта колекції. Зазвичай цей зв’язок встановлюється через конструктор.

    4. Реалізуйте методи отримання ітератора в конкретних класах колекцій. Вони повинні створювати новий ітератор того 
        класу, який здатен працювати з даним типом колекції. Колекція повинна передавати посилання на власний об’єкт до 
        конструктора ітератора.

    5. У клієнтському коді та в класах колекцій не повинно залишитися коду обходу елементів. Клієнт повинен отримувати 
        новий ітератор з об’єкта колекції кожного разу, коли йому потрібно перебрати її елементи.
               