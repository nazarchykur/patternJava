Стан
    Також відомий як: State
    
    
    
Суть патерна
    Стан — це поведінковий патерн проектування, що дає змогу об’єктам змінювати поведінку в залежності від їхнього стану. 
    Ззовні створюється враження, ніби змінився клас об’єкта.

    Основна ідея в тому, що програма може знаходитися в одному з кількох станів, які увесь час змінюють один одного. 
    Набір цих станів, а також переходів між ними, визначений наперед та скінченний. Перебуваючи в різних станах, програма 
    може по-різному реагувати на одні і ті самі події, що відбуваються з нею.
    
    Такий підхід можна застосувати і до окремих об’єктів. Наприклад, об’єкт Документ може приймати три стани: Чернетка, 
    Модерація або Опублікований. У кожному з цих станів метод опублікувати працюватиме по-різному:
        - З чернетки він надішле документ на модерацію.
        - З модерації — в публікацію, але за умови, що це зробив адміністратор.
        - В опублікованому стані метод не буде робити нічого.
        
        

Рішення
    Патерн Стан пропонує створити окремі класи для кожного стану, в якому може перебувати контекстний об’єкт, а потім 
    винести туди поведінки, що відповідають цим станам.
    
    Замість того, щоб зберігати код всіх станів, початковий об’єкт, який зветься контекстом, міститиме посилання на один 
    з об’єктів-станів і делегуватиме йому роботу в залежності від стану.
        
    Дуже важливим нюансом, який відрізняє цей патерн від Стратегії, є те, що і контекст, і конкретні стани можуть знати 
    один про одного та ініціювати переходи від одного стану до іншого.
       
       

Аналогія з життя
    Ваш смартфон поводиться по-різному в залежності від поточного стану:
        - Якщо телефон розблоковано, натискання кнопок телефону призведе до якихось дій.
        - Якщо телефон заблоковано, натискання кнопок призведе до появи екрану розблокування.
        - Якщо телефон розряджено, натискання кнопок призведе до появи екрану зарядки.



Структура
    1. Контекст зберігає посилання на об’єкт стану та делегує йому частину роботи, яка залежить від станів. Контекст працює 
        з цим об’єктом через загальний інтерфейс станів. Контекст повинен мати метод для присвоєння йому нового об’єкта-стану.
    
    2. Стан описує спільний для всіх конкретних станів інтерфейс.        
    
    3. Конкретні стани реалізують поведінки, пов’язані з певним станом контексту. Іноді доводиться створювати цілі ієрархії 
        класів станів, щоб узагальнити дублюючий код.
       
       Стан може мати зворотнє посилання на об’єкт контексту. Через нього не тільки зручно отримувати з контексту потрібну 
       інформацію, але й здійснювати зміну стану.
       
    4. І контекст, і об’єкти конкретних станів можуть вирішувати, коли і який стан буде обрано наступним. Щоб перемкнути 
        стан, потрібно подати інший об’єкт-стан до контексту.   
        



Застосування
    > Якщо у вас є об’єкт, поведінка якого кардинально змінюється в залежності від внутрішнього стану, причому типів 
        станів багато, а їхній код часто змінюється.

        + Патерн пропонує виділити в окремі класи всі поля й методи, пов’язані з визначеним станом. Початковий об’єкт буде 
            постійно посилатися на один з об’єктів-станів, делегуючи йому частину своєї роботи. Для зміни стану до контексту 
            достатньо буде підставляти інший об’єкт-стан.

    > Якщо код класу містить безліч великих, схожих один на одного умовних операторів, які вибирають поведінки в залежності 
        від поточних значень полів класу.

        + Патерн пропонує перемістити кожну гілку такого умовного оператора до власного класу. Сюди ж можна поселити й 
            усі поля, пов’язані з цим станом.

    > Якщо ви свідомо використовуєте табличну машину станів, побудовану на умовних операторах, але змушені миритися з 
        дублюванням коду для схожих станів та переходів.

        + Патерн Стан дозволяє реалізувати ієрархічну машину станів, що базується на наслідуванні. Ви можете успадкувати 
            схожі стани від одного батьківського класу та винести туди весь дублюючий код.
      


Кроки реалізації
    1. Визначтеся з класом, який відіграватиме роль контексту. Це може бути як існуючий клас, який вже має залежність від 
        стану, так і новий клас, якщо код станів «розмазаний» по кількох класах.

    2. Створіть загальний інтерфейс станів. Він повинен описувати методи, спільні для всіх станів, виявлених у контексті. 
        Зверніть увагу, що не всю поведінку контексту потрібно переносити до стану, а тільки ту, яка залежить від станів.

    3. Для кожного фактичного стану створіть клас, який реалізує інтерфейс стану. Перемістіть код, пов’язаний з конкретними 
        станами, до потрібних класів. Зрештою, всі методи інтерфейсу стану повинні бути реалізовані в усіх класах станів.

        При перенесенні поведінки з контексту ви можете зіткнутися з тим, що ця поведінка залежить від приватних полів 
        або методів контексту, до яких немає доступу з об’єкта стану. Є кілька способів, щоб обійти цю проблему.

        Найпростіший — залишити поведінку всередині контексту, викликаючи його з об’єкта стану. З іншого боку, ви можете 
        зробити класи станів вкладеними до класу контексту, і тоді вони отримають доступ до всіх приватних частин контексту. 
        Останній спосіб, щоправда, доступний лише в деяких мовах програмування (наприклад, Java, C#).

    4. Створіть в контексті поле для зберігання об’єктів-станів, а також публічний метод для зміни значення цього поля.

    5. Старі методи контексту, в яких перебував залежний від стану код, замініть на виклики відповідних методів об’єкта-стану.

    6. В залежності від бізнес-логіки, розмістіть код, який перемикає стан контексту, або всередині контексту, або всередині 
        класів конкретних станів.



Переваги та недоліки
    + Позбавляє від безлічі великих умовних операторів машини станів.
    + Концентрує в одному місці код, пов’язаний з певним станом.
    + Спрощує код контексту.
    
    - Може невиправдано ускладнити код, якщо станів мало, і вони рідко змінюються.         



Відносини з іншими патернами
    > Міст, Стратегія та Стан (а також трохи і Адаптер) мають схожі структури класів — усі вони побудовані за принципом 
        «композиції», тобто делегування роботи іншим об’єктам. Проте вони відрізняються тим, що вирішують різні проблеми. 
        Пам’ятайте, що патерни — це не тільки рецепт побудови коду певним чином, але й описування проблем, які призвели 
        до такого рішення.
    
    > Стан можна розглядати як надбудову над Стратегією. Обидва патерни використовують композицію, щоб змінювати поведінку 
        головного об’єкта, делегуючи роботу вкладеним об’єктам-помічникам. Проте в Стратегії ці об’єкти не знають один 
        про одного і жодним чином не пов’язані. У Стані конкретні стани самостійно можуть перемикати контекст.
        