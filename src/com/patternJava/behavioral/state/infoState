Стан — це поведінковий патерн проектування, що дає змогу об’єктам змінювати поведінку в залежності від їхнього стану. 
      
      Дозволяє об'єктові варіювати свою поведінку залежно від внутрішнього стану.
      
      Основна ідея в тому, що програма може знаходитися в одному з кількох станів, які увесь час змінюють один одного. 
      Набір цих станів, а також переходів між ними, визначений наперед та кінцевий. Перебуваючи в різних станах, 
      програма може по-різному реагувати на одні і ті самі події, що відбуваються з нею.
      
   Наприклад: кнопка вкл/викл  веде себе по рідному взалежності від стану телефона = чи він включений чи виключений, чи заблокований =
   натиск на кнопку 
   
   
   Замість того, щоб зберігати код всіх станів, початковий об’єкт, який зветься контекстом, міститиме посилання 
      на один з об’єктів-станів і делегуватиме йому роботу в залежності від стану.
   
   Завдяки тому, що об’єкти станів матимуть спільний інтерфейс, контекст зможе делегувати роботу стану, 
     не прив’язуючись до його класу. Поведінку контексту можна буде змінити в будь-який момент, підключивши до нього інший об’єкт-стан.
    
   Дуже важливим нюансом, який відрізняє цей патерн від Стратегії, є те, що і контекст, і конкретні стани можуть 
     знати один про одного та ініціювати переходи від одного стану до іншого.
    
-------------------------    

Слід використовувати шаблон Стан у випадках, коли:

1) поведінка об'єкта залежить від його стану та повинна змінюватись під час виконання програми;
2) у коді операцій зустрічаються складні умовні оператори, у котрих вибір гілки залежить від стану. 
Зазвичай у такому разі стан представлено константами, що перелічуються. До того ж часто одна й та ж структура 
умовного оператору повторюється у декількох операціях. Шаблон Стан пропонує замінити кожну гілку окремим класом. 
Це дозволить трактувати стан об'єкта як самостійний об'єкт, котрий може змінитися незалежно від інших.      
       
       
==================================================================================================

1) Контекст зберігає посилання на об’єкт стану та делегує йому частину роботи, яка залежить від станів. 
  Контекст працює з цим об’єктом через загальний інтерфейс станів. Контекст повинен мати метод для присвоєння 
  йому нового об’єкта-стану.
  
2) Стан описує спільний для всіх конкретних станів інтерфейс.

3)  Конкретні стани реалізують поведінки, пов’язані з певним станом контексту. Іноді доводиться створювати цілі 
    ієрархії класів станів, щоб узагальнити дублюючий код.
    
    Стан може мати зворотнє посилання на об’єкт контексту. Через нього не тільки зручно отримувати з контексту 
    потрібну інформацію, але й здійснювати зміну стану.  
    
4) І контекст, і об’єкти конкретних станів можуть вирішувати, коли і який стан буде обрано наступним. 
   Щоб перемкнути стан, потрібно подати інший об’єкт-стан до контексту.     
   
==================================================================================================
 Застосування:
 -------------
   ! - Якщо у вас є об’єкт, поведінка якого кардинально змінюється в залежності від внутрішнього стану, 
        причому типів станів багато, а їхній код часто змінюється.
   * - Патерн пропонує виділити в окремі класи всі поля й методи, пов’язані з визначеним станом. Початковий об’єкт 
       буде постійно посилатися на один з об’єктів-станів, делегуючи йому частину своєї роботи. Для зміни стану до 
       контексту достатньо буде підставляти інший об’єкт-стан
------------
   ! -  Якщо код класу містить безліч великих, схожих один на одного умовних операторів, які вибирають поведінки 
        в залежності від поточних значень полів класу.    
   * -  Патерн пропонує перемістити кожну гілку такого умовного оператора до власного класу. 
        Сюди ж можна поселити й усі поля, пов’язані з цим станом.    