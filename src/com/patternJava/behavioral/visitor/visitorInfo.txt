Відвідувач — це поведінковий патерн проектування, що дає змогу додавати до програми нові операції, 
             не змінюючи класи об’єктів, над якими ці операції можуть виконуватися.


============================================================================================

 Структура:
 ----------
 
 1)  Відвідувач описує спільний для всіх типів відвідувачів інтерфейс. Він оголошує набір методів, 
     що відрізняються типом вхідного параметра. Кожному класу конкретних елементів повинен підходити свій метод. 
     В мовах, які підтримують перевантаження методів, ці методи можуть мати однакові імена, але типи їхніх параметрів повинні відрізнятися.
 
 2) Конкретні відвідувачі реалізують якусь особливу поведінку для всіх типів елементів, 
      які можна подати через методи інтерфейсу відвідувача.
      
3) Елемент описує метод прийому відвідувача. Цей метод повинен мати лише один параметр, оголошений з 
      типом загального інтерфейсу відвідувачів.
      
4) Конкретні елементи реалізують методи приймання відвідувача. Мета цього методу — викликати той метод відвідування, 
    який відповідає типу цього елемента. Так відвідувач дізнається, з яким типом елементу він працює.
    
5) Клієнтом зазвичай виступає колекція або складний складовий об’єкт, наприклад, дерево Компонувальника. 
    Здебільшого, клієнт не прив’язаний до конкретних класів елементів, працюючи з ними через загальний інтерфейс елементів.    
    
    
 =======================================================================================================================
 
  Застосування:
  --------------
  !- Якщо вам потрібно виконати якусь операцію над усіма елементами складної структури об’єктів, наприклад, деревом.   
  *- Відвідувач дозволяє застосовувати одну і ту саму операцію до об’єктів різних класів.
--------------    
  !- Якщо над об’єктами складної структури об’єктів потрібно виконувати деякі не пов’язані між собою операції, 
       але ви не хочете «засмічувати» класи такими операціями.
  *- Відвідувач дозволяє витягти споріднені операції з класів, що складають структуру об’єктів, помістивши їх до 
       одного класу-відвідувача. Якщо структура об’єктів використовується в декількох програмах, то патерн дозволить 
       кожній програмі мати тільки потрібні в ній операції.
--------------
  !-  Якщо нова поведінка має сенс тільки для деяких класів з існуючої ієрархії.
  *-  Відвідувач дозволяє визначити поведінку тільки для цих класів, залишивши її порожньою для всіх інших.
         
         
========================================================================================================================    
Кроки реалізації:
-----------------
1) Створіть інтерфейс відвідувача й оголосіть у ньому методи «відвідування» для кожного класу елемента, який існує в програмі.

    наприклад
        визначаємо інтерфейс візітора, який має перелік перегруженого метода для роботи з кожним типом елемента
        interface ComputerPartVisitor {
            void visit(Computer computer);
            void visit(Mouse mouse);
            void visit(Keyboard keyboard);
            void visit(Monitor monitor);
        }

2) Опишіть інтерфейс елементів. Якщо ви працюєте з уже існуючими класами, оголосіть абстрактний метод прийняття 
     відвідувачів у базовому класі ієрархії елементів.
     
     accept(Visitor visitor);

3) Реалізуйте методи прийняття в усіх конкретних елементах. Вони повинні переадресовувати виклики тому методу 
     відвідувача, в якому тип параметра збігається з поточним класом елемента.
     
         @Override
         public int accept(Visitor visitor) {
             return visitor.visit(this);
         }

4) Ієрархія елементів повинна знати тільки про загальний інтерфейс відвідувачів. З іншого боку, відвідувачі 
    знатимуть про всі класи елементів.

5) Для кожної нової поведінки створіть свій власний конкретний клас. Пристосуйте цю поведінку для роботи з усіма 
     наявними типами елементів, реалізувавши всі методи інтерфейсу відвідувачів.

6) Клієнт створюватиме об’єкти відвідувачів, а потім передаватиме їх елементам через метод прийняття.     



========================================================================================================================

Visitor pattern is used when we have to perform an operation on a group of similar kind of Objects. 
   With the help of visitor pattern, we can move the operational logic from the objects to another class.

For example, think of a Shopping cart where we can add different type of items (Elements). 
When we click on checkout button, it calculates the total amount to be paid. Now we can have the calculation logic in 
item classes or we can move out this logic to another class using visitor pattern.

Notice that accept method takes Visitor argument.

Notice the implementation of accept() method in concrete classes, its calling visit() method of Visitor and passing itself as argument.

We have visit() method for different type of items in Visitor interface that will be implemented by concrete visitor class.

========================================================================================================================

Visitor Pattern Benefits
-------------------------
The benefit of this pattern is that if the logic of operation changes, then we need to make change only in the visitor 
   implementation rather than doing it in all the item classes.

Another benefit is that adding a new item to the system is easy, it will require change only in visitor interface and implementation and existing item classes will not be affected.

Visitor Pattern Limitations
----------------------------
The drawback of visitor pattern is that we should know the return type of visit() methods at the time of designing 
   otherwise we will have to change the interface and all of its implementations.  

Another drawback is that if there are too many implementations of visitor interface, it makes it hard to extend.
