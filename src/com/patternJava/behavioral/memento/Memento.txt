Знімок
    Також відомий як: Memento
    
    
    
Суть патерна
    Знімок — це поведінковий патерн проектування, що дає змогу зберігати та відновлювати минулий стан об’єктів, не 
    розкриваючи подробиць їхньої реалізації.    
    
    
    +-----------------------+                +-----------------+        +----------------------+
    |   Originator          |                |     Memento     |        |      Caretaker       |
    +-----------------------+                +-----------------+        +----------------------+
    | - state               |                | - state         |        | - history: Stack     |
    +-----------------------+                +-----------------+        +----------------------+
    | + createMemento(): M  |                | + getState(): M |        | + save(): void       |
    | + setMemento(M): void |                |                 |        | + undo(): void       |
    +-----------------------+                +-----------------+        +----------------------+
                                                      |                               |
                                                      |                               |
                                                      | creates                       |
                                                      |                               |
                                                      V                               V
                                               +----------+                    +----------+
                                               | Client   |                    | Client   |
                                               +----------+                    +----------+
                                               |          |                    |          |
                                               +----------+                    +----------+

    
    In this diagram, there are three main components:
    
        > Originator: This is the object that has an internal state that it wants to save and restore. It creates mementos 
            that store its state, and can restore its state from a memento.
        > Memento: This is an immutable object that stores the state of the Originator at a specific point in time. It 
            provides a way for the Originator to restore its state to that point in time.
        > Caretaker: This is an object that manages a collection of mementos. It can save mementos and undo changes to 
            the Originator's state by restoring a previous memento.
    
    The Client interacts with the Originator to modify its state, and with the Caretaker to save and restore its state. 
    The Originator and Caretaker classes are typically decoupled from each other, so that changes to one do not affect the other.
    
    
    
Проблема
    Припустімо, ви пишете програму текстового редактора. Крім звичайного редагування, ваш редактор дозволяє змінювати 
    форматування тексту, вставляти малюнки та інше.
    
    В певний момент ви вирішили надати можливість скасовувати усі ці дії. Для цього вам потрібно зберігати поточний стан 
    редактора перед тим, як виконати будь-яку дію. Якщо користувач вирішить скасувати свою дію, ви візьмете копію стану 
    з історії та відновите попередній стан редактора.
    
    Щоб зробити копію стану об’єкта, достатньо скопіювати значення полів. Таким чином, якщо ви зробили клас редактора 
    достатньо відкритим, то будь-який інший клас зможе зазирнути всередину, щоб скопіювати його стан.
    
    Здавалося б, які проблеми? Тепер будь-яка операція зможе зробити резервну копію редактора перед виконанням своєї дії. 
    Але такий наївний підхід забезпечить вам безліч проблем у майбутньому. Адже, якщо ви вирішите провести рефакторинг — 
    прибрати або додати кілька полів до класу редактора — доведеться змінювати код усіх класів, які могли копіювати стан редактора.
    
    Навіть найпримітивніший редактор повинен мати декілька полів для зберігання поточного тексту, позиції курсора та 
    прокручування екрану. Щоб зробити копію стану, вам потрібно додати значення всіх цих полів до деякого «контейнера».
    
    ...
    


Рішення
    Усі проблеми, описані вище, виникають через порушення інкапсуляції, коли одні об’єкти намагаються зробити роботу за 
    інших, проникаючи до їхньої приватної зони, щоб зібрати необхідні для операції дані.
    
    Патерн Знімок доручає створення копії стану об’єкта самому об’єкту, який цим станом володіє. Замість того, щоб робити 
    знімок «ззовні», наш редактор сам зробить копію своїх полів, адже йому доступні всі поля, навіть приватні.
    
    Патерн пропонує тримати копію стану в спеціальному об’єкті-знімку з обмеженим інтерфейсом, що дозволяє, наприклад, 
    дізнатися дату виготовлення або назву знімка. Проте, знімок повинен бути відкритим для свого творця і дозволяти 
    прочитати та відновити його внутрішній стан.
    
    Така схема дозволяє творцям робити знімки та віддавати їх на зберігання іншим об’єктам, що називаються опікунами. 
    Опікунам буде доступний тільки обмежений інтерфейс знімка, тому вони ніяк не зможуть вплинути на «нутрощі» самого знімку. 
    У потрібний момент опікун може попросити творця відновити свій стан, передавши йому відповідний знімок.
    
    У нашому прикладі з редактором опікуном можна зробити окремий клас, який зберігатиме список виконаних операцій. 
    Обмежений інтерфейс знімків дозволить демонструвати користувачеві гарний список з назвами й датами виконаних операцій. 
    Коли ж користувач вирішить скасувати операцію, клас історії візьме останній знімок зі стека та надішле його об’єкту 
    редактора для відновлення.
  
  
  
Структура
    1. Творець може створювати знімки свого стану, а також відтворювати минулий стан, якщо до нього подати готовий знімок.
    
    2. Знімок — це простий об’єкт даних, який містить стан творця. Надійніше за все зробити об’єкти знімків незмінними, 
        встановлюючи в них стан тільки через конструктор.
    
    3. Опікун повинен знати, коли робити знімок творця та коли його потрібно відновлювати.
       
       Опікун може зберігати історію минулих станів творця у вигляді стека знімків. Коли треба буде скасувати останню 
       операцію, він візьме «верхній» знімок зі стеку та передасть його творцеві для відновлення.
    
    4. У даній реалізації знімок — це внутрішній клас по відношенню до класу творця. Саме тому він має повний доступ до 
        всіх полів та методів творця, навіть приватних. З іншого боку, опікун не має доступу ані до стану, ані до методів 
        знімків, а може лише зберігати посилання на ці об’єкти.
  


Застосування
    > Коли вам потрібно зберігати миттєві знімки стану об’єкта (або його частини) для того, щоб об’єкт можна було відновити 
        в тому самому стані.

        + Патерн Знімок дозволяє створювати будь-яку кількість знімків об’єкта і зберігати їх незалежно від об’єкта, з 
            якого роблять знімок. Знімки часто використовують не тільки для реалізації операції скасування, але й для 
            транзакцій, коли стан об’єкта потрібно «відкотити», якщо операція не була вдалою.

    > Коли пряме отримання стану об’єкта розкриває приватні деталі його реалізації, порушуючи інкапсуляцію.

        + Патерн пропонує виготовити знімок саме вихідному об’єкту, тому що йому доступні всі поля, навіть приватні.



Кроки реалізації
    1. Визначте клас творця, об’єкти якого повинні створювати знімки свого стану.
    
    2. Створіть клас знімка та опишіть в ньому ті ж самі поля, які є в оригінальному класі-творці.
    
    3. Зробіть об’єкти знімків незмінними. Вони повинні одержувати початкові значення тільки один раз, через власний конструктор.
    
    4. Якщо ваша мова програмування це дозволяє, зробіть клас знімка вкладеним у клас творця.
    
        Якщо ні, вийміть з класу знімка порожній інтерфейс, який буде доступним іншим об’єктам програми. Згодом ви можете 
        додати до цього інтерфейсу деякі допоміжні методи, що дають доступ до метаданих знімка, але прямий доступ до даних 
        творця повинен бути виключеним.
    
    5. Додайте до класу творця метод одержання знімків. Творець повинен створювати нові об’єкти знімків, передаючи значення 
        своїх полів через конструктор.
    
        Сигнатура методу повинна повертати знімки через обмежений інтерфейс, якщо він у вас є. Сам клас повинен працювати 
        з конкретним класом знімка.
    
    6. Додайте до класу творця метод відновлення зі знімка. Щодо прив’язки до типів, керуйтеся тією ж логікою, що і в пункті 4.
    
    7. Опікуни, незалежно від того, чи це історія операцій, чи об’єкти команд, чи щось інше, повинні знати про те, коли 
        запитувати знімки у творця, де їх зберігати та коли відновлювати.
    
    8. Зв’язок опікунів з творцями можна перенести всередину знімків. У цьому випадку кожен знімок буде прив’язаний до 
        свого творця і повинен буде сам відновлювати його стан. Але це працюватиме або якщо класи знімків вкладені до 
        класів творців, або якщо творці мають відповідні сетери для встановлення значень своїх полів.



Переваги та недоліки
    + Не порушує інкапсуляцію вихідного об’єкта.
    + Спрощує структуру вихідного об’єкта. Йому не потрібно зберігати історію версій свого стану.
    
    - Вимагає багато пам’яті, якщо клієнти дуже часто створюють знімки.
    - Може спричинити додаткові витрати пам’яті, якщо об’єкти, що зберігають історію, не звільняють ресурси, зайняті застарілими знімками.
    - В деяких мовах (наприклад, PHP, Python, JavaScript) складно гарантувати, щоб лише вихідний об’єкт мав доступ до стану знімка.
         


Відносини з іншими патернами
    > Команду та Знімок можна використовувати спільно для реалізації скасування операцій. У цьому випадку об’єкти команд 
        відповідатимуть за виконання дії над об’єктом, а знімки зберігатимуть резервну копію стану цього об’єкта, зроблену 
        перед запуском команди.

    > Знімок можна використовувати разом з Ітератором, щоб зберегти поточний стан обходу структури даних та повернутися 
        до нього в майбутньому, якщо буде потрібно.

    > Знімок іноді можна замінити Прототипом, якщо об’єкт, чий стан потрібно зберігати в історії, досить простий, не має 
        посилань на зовнішні ресурси або їх можна легко відновити.
              